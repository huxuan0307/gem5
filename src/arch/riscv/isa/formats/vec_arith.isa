let {{
    def setDestWrapper(destRegId):
        return "setDestRegIdx(_numDestRegs++, " + destRegId + ");\n" + \
            "_numVecDestRegs++;\n"
    def setSrcWrapper(srcRegId):
        return "setSrcRegIdx(_numSrcRegs++, " + srcRegId + ");\n"
    def setSrcVm():
        return "if (!this->vm)\n" + \
            "    setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));"
    def vmDeclAndReadData():
        return '''
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!this->vm) {
                tmp_v0 = xc->readVecRegOperand(this, _numSrcRegs-1);
                v0 = tmp_v0.as<uint8_t>();
            }
        '''
    def loopWrapper(code):
        return "for (uint32_t i = 0; i < this->micro_vl; i++) {\n" + \
            code + "}\n"
    def maskCondWrapper(code):
        return "if (this->vm || elem_mask(v0, ei)) {\n" + \
            code + "}\n"
    def eiDeclarePrefix(code):
        return "uint32_t ei = i + this->microVlmax() * this->micro_idx;\n" + \
            code
}};

def format VectorFloatFormat(code, *flags) {{
    iop = InstObjParams(name,
        Name,
        'VectorFloatMacroOp',
        {'code': code},
        flags)
    microiop = InstObjParams(name + "_micro",
        Name + "Micro",
        'VectorFloatMicroOp',
        {'code': code},
        flags)
    header_output = \
        VectorFloatMicroDeclare.subst(microiop) + \
        VectorFloatMicroConstructor.subst(microiop) + \
        VectorFloatMicroExecute.subst(microiop) + \
        VectorFloatMacroDeclare.subst(iop) + \
        VectorFloatMacroConstructor.subst(iop)
    decode_block = VectorFloatDecodeBlock.subst(iop)
}};

def format VectorIntFormat(code, category, *flags) {{
    iop = InstObjParams(name,
        Name,
        'VectorIntMacroOp',
        {'code': code},
        flags)
    split_name = name.split("_")
    insts_neednot_mask = ["vmv"]
    need_vm = split_name[0] not in insts_neednot_mask
    mask_cond = need_vm and ('m' not in split_name[1])
    need_elem_idx = mask_cond or code.find("ei") != -1

    dest_reg_id = "RegId(VecRegClass, extMachInst.vd + _micro_idx)"
    src1_reg_id = ""
    if category == "OPIVV":
        src1_reg_id = "RegId(VecRegClass, extMachInst.vs1 + _micro_idx)"
    elif category == 'OPIVX':
        src1_reg_id = "RegId(IntRegClass, extMachInst.rs1)"
    elif category == 'OPIVI':
        pass
    else:
        error("not supported category for VectorIntFormat: %s" % category)
    src2RegId = "RegId(VecRegClass, extMachInst.vs2 + _micro_idx)"

    set_dest_reg_idx = setDestWrapper(dest_reg_id)
    # set_src_reg_idx
    set_src_reg_idx = ""
    if category != 'OPIVI':
        set_src_reg_idx += setSrcWrapper(src1_reg_id)
    set_src_reg_idx += setSrcWrapper(src2RegId)
    if need_vm:
        set_src_reg_idx += setSrcVm()
    # code
    if mask_cond:
        code = maskCondWrapper(code)
    if need_elem_idx:
        code = eiDeclarePrefix(code)
    code = loopWrapper(code)

    vm_decl_rd = ""
    if need_vm:
        vm_decl_rd = vmDeclAndReadData()

    microiop = InstObjParams(name + "_micro",
        Name + "Micro",
        'VectorIntMicroOp',
        {'code': code,
        'set_dest_reg_idx': set_dest_reg_idx,
        'set_src_reg_idx': set_src_reg_idx,
        'vm_decl_rd': vm_decl_rd},
        flags)

    header_output = \
        VectorIntMicroDeclare.subst(microiop) + \
        VectorIntMicroConstructor.subst(microiop) + \
        VectorIntMicroExecute.subst(microiop) + \
        VectorIntMacroDeclare.subst(iop) + \
        VectorIntMacroConstructor.subst(iop)
    decode_block = VectorIntDecodeBlock.subst(iop)
}};

def format VectorIntMaskFormat(code, category, *flags) {{
    iop = InstObjParams(name,
        Name,
        'VectorIntMaskMacroOp',
        {'code': code},
        flags)
    dest_reg_id = "RegId(VecRegClass, extMachInst.vd)"
    src1_reg_id = ""
    if category == "OPIVV":
        src1_reg_id = "RegId(VecRegClass, extMachInst.vs1 + _micro_idx)"
    elif category == "OPIVX":
        src1_reg_id = "RegId(IntRegClass, extMachInst.rs1)"
    elif category == "OPIVI":
        pass
    else:
        error("not supported category for VectorIntFormat: %s" % category)
    src2RegId = "RegId(VecRegClass, extMachInst.vs2 + _micro_idx)"
    set_dest_reg_idx = setDestWrapper(dest_reg_id)
    set_src_reg_idx = ""
    if category != 'OPIVI':
        set_src_reg_idx += setSrcWrapper(src1_reg_id)
    set_src_reg_idx += setSrcWrapper(src2RegId)
    set_src_reg_idx += setSrcVm()
    vm_decl_rd = vmDeclAndReadData()

    code = eiDeclarePrefix(code)
    code = loopWrapper(code)

    microiop = InstObjParams(name + "_micro",
        Name + "Micro",
        'VectorIntMicroOp',
        {'code': code,
        'set_dest_reg_idx': set_dest_reg_idx,
        'set_src_reg_idx': set_src_reg_idx,
        'vm_decl_rd': vm_decl_rd},
        flags)
    header_output = \
        VectorIntMaskMicroDeclare.subst(microiop) + \
        VectorIntMaskMicroConstructor.subst(microiop) + \
        VectorIntMaskMicroExecute.subst(microiop) + \
        VectorIntMaskMacroDeclare.subst(iop) + \
        VectorIntMaskMacroConstructor.subst(iop)
    decode_block = VectorIntDecodeBlock.subst(iop)
}};
