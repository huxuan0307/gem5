output exec {{
    uint64_t
    SEW(const uint64_t vtype) {
        uint8_t vsew = bits(vtype, 5, 3);
        uint64_t result;
        switch (vsew) {
        case 0: result = 8; break;
        case 1: result = 16; break;
        case 2: result = 32; break;
        case 3: result = 64; break;
        default:
            panic("invalid SEW");
        }

        return result;
    }

    uint64_t
    LMUL(const uint64_t vtype) {
        uint8_t vlmul = bits(vtype, 2, 0);
        uint64_t result;
        switch (vlmul) {
        case 0: result = 1; break;
        case 1: result = 2; break;
        case 2: result = 4; break;
        case 3: result = 8; break;
        default:
            panic("invalid LMUL");
        }

        return result;
    }
}};


def template VConfExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        %(op_decl)s;
        %(op_rd)s;

        uint64_t rd = srcRegIdx(0).index();

        // Assigned in code block
        uint64_t rs1;
        uint64_t vtype;
        %(code)s;

        uint64_t avl;
        if (rd == 0 && rs1 == 0) {
            avl = xc->readMiscReg(MISCREG_VL);
        } else if (rs1 == 0) {
            avl = std::numeric_limits<uint64_t>::max();
        } else {
            avl = srcRegIdx(rs1).index();
        }

        uint64_t VLMAX = LMUL(vtype) *
                            (uint64_t)gem5::RiscvISA::VLEN / SEW(vtype);
        uint64_t vl = VLMAX;
        if (avl <= VLMAX) {
            vl = avl;
        }

        // Rd = vl;
        xc->setIntRegOperand(this, 0, vl);

        xc->setMiscReg(MISCREG_VL, vl);
        xc->setMiscReg(MISCREG_VTYPE, vtype);
        %(op_wb)s;
        return NoFault;
    }
}};

def template VIntExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        uint64_t avl = xc->readMiscReg(MISCREG_VL);
        uint64_t vtype = xc->readMiscReg(MISCREG_VTYPE);

        switch (SEW(vtype)) {
            case 8: {
                using vi = int8_t;
                %(op_decl)s;
                %(op_rd)s;
                const TheISA::VecRegContainer& tmp_v0 =
                    xc->readVecRegOperand(this, 0);
                auto v0 = tmp_v0.as<vi>();
                for (unsigned i = 0; i < avl; i++) {
                    if(vm || v0[i]) {
                        %(code)s;
                    }
                }
                %(op_wb)s;
                break;
            }
            case 16: {
                using vi = int16_t;
                %(op_decl)s;
                %(op_rd)s;
                const TheISA::VecRegContainer& tmp_v0 =
                    xc->readVecRegOperand(this, 0);
                auto v0 = tmp_v0.as<vi>();
                for (unsigned i = 0; i < avl; i++) {
                    if(vm || v0[i]) {
                        %(code)s;
                    }
                }
                %(op_wb)s;
                break;
            }
            case 32: {
                using vi = int32_t;
                %(op_decl)s;
                %(op_rd)s;
                const TheISA::VecRegContainer& tmp_v0 =
                    xc->readVecRegOperand(this, 0);
                auto v0 = tmp_v0.as<vi>();
                for (unsigned i = 0; i < avl; i++) {
                    if(vm || v0[i]) {
                        %(code)s;
                    }
                }
                %(op_wb)s;
                break;
            }
            case 64: {
                using vi = int64_t;
                %(op_decl)s;
                %(op_rd)s;
                const TheISA::VecRegContainer& tmp_v0 =
                    xc->readVecRegOperand(this, 0);
                auto v0 = tmp_v0.as<vi>();
                for (unsigned i = 0; i < avl; i++) {
                    if(vm || v0[i]) {
                        %(code)s;
                    }
                }
                %(op_wb)s;
                break;
            }
            default:
                panic("invalid SEW");
        }

        return NoFault;
    }
}};

def format VIntOp(code, *flags) {{
    iop = InstObjParams(name, Name, 'VIntOp', code, flags)
    header_output = BasicDeclare.subst(iop)
    decoder_output = BasicConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = VIntExecute.subst(iop)
}};

def format VConfOp(code, *flags) {{
    iop = InstObjParams(name, Name, 'VConfOp', code, flags)
    header_output = BasicDeclare.subst(iop)
    decoder_output = BasicConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = VConfExecute.subst(iop)
}};

def format VMemLoadOp(code, *flags) {{
    iop = InstObjParams(name, Name, 'VMemLoadOp', code, flags)
    header_output = BasicDeclare.subst(iop)
    decoder_output = BasicConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = BasicExecute.subst(iop)
}};