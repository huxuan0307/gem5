output exec {{
    uint64_t
    SEW(const uint64_t vtype) {
        uint8_t vsew = bits(vtype, 5, 3);
        uint64_t result;
        switch (vsew) {
        case 0: result = 8; break;
        case 1: result = 16; break;
        case 2: result = 32; break;
        case 3: result = 64; break;
        default:
            panic("invalid SEW");
        }

        return result;
    }

    uint64_t
    LMUL(const uint64_t vtype) {
        uint8_t vlmul = bits(vtype, 2, 0);
        uint64_t result;
        switch (vlmul) {
        case 0: result = 1; break;
        case 1: result = 2; break;
        case 2: result = 4; break;
        case 3: result = 8; break;
        default:
            panic("invalid LMUL");
        }

        return result;
    }
}};


def template VConfExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        %(op_decl)s;
        %(op_rd)s;
        %(code)s;
        xc->setMiscReg(MISCREG_VL, vl);
        xc->setMiscReg(MISCREG_VTYPE, vtype);
        %(op_wb)s;
        return NoFault;
    }
}};

def template VIntExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        uint64_t vl = xc->readMiscReg(MISCREG_VL);
        uint64_t vtype = xc->readMiscReg(MISCREG_VTYPE);
        auto tc = xc->tcBase();
        const RiscvISA::vreg_t& tmp_v0 = tc->readVecReg(RegId(VecRegClass, 0));

        switch (SEW(vtype)) {
            case 8: {
                using vi = int8_t;
                %(op_decl)s;
                %(op_rd)s;
                auto v0 = tmp_v0.as<vi>();
                for (unsigned i = 0; i < vl; i++) {
                    if(vm || v0[i]) {
                        %(code)s;
                    }
                }
                %(op_wb)s;
                break;
            }
            case 16: {
                using vi = int16_t;
                %(op_decl)s;
                %(op_rd)s;
                auto v0 = tmp_v0.as<vi>();
                for (unsigned i = 0; i < vl; i++) {
                    if(vm || v0[i]) {
                        %(code)s;
                    }
                }
                %(op_wb)s;
                break;
            }
            case 32: {
                using vi = int32_t;
                %(op_decl)s;
                %(op_rd)s;
                auto v0 = tmp_v0.as<vi>();
                for (unsigned i = 0; i < vl; i++) {
                    if(vm || v0[i]) {
                        %(code)s;
                    }
                }
                %(op_wb)s;
                break;
            }
            case 64: {
                using vi = int64_t;
                %(op_decl)s;
                %(op_rd)s;
                auto v0 = tmp_v0.as<vi>();
                for (unsigned i = 0; i < vl; i++) {
                    if(vm || v0[i]) {
                        %(code)s;
                    }
                }
                %(op_wb)s;
                break;
            }
            default:
                panic("invalid SEW");
        }

        return NoFault;
    }
}};

def format VIntOp(code, *flags) {{
    iop = InstObjParams(name, Name, 'VIntOp', code, flags)
    header_output = BasicDeclare.subst(iop)
    decoder_output = BasicConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = VIntExecute.subst(iop)
}};

def format VConfOp(code, *flags) {{
    iop = InstObjParams(name, Name, 'VConfOp', code, flags)
    header_output = BasicDeclare.subst(iop)
    decoder_output = BasicConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = VConfExecute.subst(iop)
}};

////////////////////////////////////////////////////////////////////
//
// Vector memory operation instructions
//
def template VMemLoadStoreOpDeclare {{
    /**
     * Static instruction class for "%(mnemonic)s".
     */
    class %(class_name)s : public %(base_class)s
    {
      private:
        %(reg_idx_arr_decl)s;

      public:
        /// Constructor.
        %(class_name)s(ExtMachInst machInst);

        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, Trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          Trace::InstRecord *) const override;
    };
}};

def template VMemLoadStoreOpConstructor {{
    %(class_name)s::%(class_name)s(ExtMachInst machInst):
        %(base_class)s("%(mnemonic)s", machInst, %(op_class)s, 
        (MEW<<3)|WIDTH, VM)
    {
        %(set_reg_idx_arr)s;
        %(constructor)s;
    }
}};

let {{
    def VMemLoadStoreOpBase(name, Name, ea_code, memacc_code,
            mem_flags, inst_flags, base_class, postacc_code='',
            decode_template=BasicDecode, exec_template_base=''):
        # Make sure flags are in lists (convert to lists if not).
        mem_flags = makeList(mem_flags)
        inst_flags = makeList(inst_flags)

        iop = InstObjParams(name, Name, base_class,
            {'ea_code': ea_code,
            'memacc_code': memacc_code, 'postacc_code': postacc_code },
            inst_flags)

        if mem_flags:
            mem_flags = [ 'Request::%s' % flag for flag in mem_flags ]
            s = '\n\tthis->memAccessFlags = ' + '|'.join(mem_flags) + ';'
            iop.constructor += s

        # select templates
        fullExecTemplate = eval(exec_template_base + 'Execute')
        initiateAccTemplate = eval(exec_template_base + 'InitiateAcc')
        completeAccTemplate = eval(exec_template_base + 'CompleteAcc')

        # (header_output, decoder_output, decode_block, exec_output)
        return (VMemLoadStoreOpDeclare.subst(iop),
            VMemLoadStoreOpConstructor.subst(iop),
            decode_template.subst(iop),
            fullExecTemplate.subst(iop) +
            initiateAccTemplate.subst(iop) +
            completeAccTemplate.subst(iop))
}};

def template VMemLoadExecute {{
    Fault %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        auto tc = xc->tcBase();
        size_t vl = RiscvStaticInst::getCurVL(tc);
        
        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        static const std::vector<bool> byte_enable(vl * this->sew, true);

        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.vs == static_cast<int>(VPUStatus::OFF))
            fault = std::make_shared<IllegalInstFault>("VPU is off", machInst);

        if (fault == NoFault) {
            fault = readMemAtomic(xc, EA, Mem.as<uint8_t>(), 
                vl * this->sew, this->memAccessFlags, byte_enable);
        }

        if (fault == NoFault) {
            const RiscvISA::vreg_t& tmp_v0 = tc->readVecReg(RegId(VecRegClass, 0));
            auto v0 = tmp_v0.as<uint8_t>();
            for (int i=0; i<vl; i++) {
                if (vm || v0[i]) {
                    %(memacc_code)s;
                }
            }
            %(op_wb)s;
        }

        return fault;
    }
}};

def template VMemLoadInitiateAcc {{
    Fault %(class_name)s::initiateAcc(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        %(op_src_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        return initiateMemRead(xc, traceData, EA, Mem, 
            this->memAccessFlags);
    }
}};

def template VMemLoadCompleteAcc {{
    Fault %(class_name)s::completeAcc(PacketPtr pkt, ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        auto tc = xc->tcBase();
        size_t vl = RiscvStaticInst::getCurVL(tc);

        %(op_decl)s;
        %(op_rd)s;

        
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.vs == static_cast<int>(VPUStatus::OFF))
            fault = std::make_shared<IllegalInstFault>("VPU is off", machInst);

        if (fault == NoFault) {
            const RiscvISA::vreg_t& tmp_v0 = tc->readVecReg(RegId(VecRegClass, 0));
            auto v0 = tmp_v0.as<uint8_t>();
            memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(),
                pkt->getSize());
            for (int i=0; i<vl; i++) {
                if (vm || v0[i]) {
                    %(memacc_code)s;
                }
            }
        }

        if (fault == NoFault) {
            %(op_wb)s;
        }

        return fault;
    }
}};

def template VMemStoreExecute {{
    Fault %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        auto tc = xc->tcBase();
        size_t vl = RiscvStaticInst::getCurVL(tc);
        
        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        static const std::vector<bool> byte_enable(vl * this->sew, true);

        if (fault == NoFault) {
            fault = readMemAtomic(xc, EA, Mem.as<uint8_t>(), 
                vl * this->sew, this->memAccessFlags, byte_enable);
        }

        if (fault == NoFault) {
            const RiscvISA::vreg_t& tmp_v0 = tc->readVecReg(RegId(VecRegClass, 0));
            auto v0 = tmp_v0.as<uint8_t>();
            for (int i=0; i<vl; i++) {
                if (vm || v0[i]) {
                    %(memacc_code)s;
                }
            }
            fault = writeMemAtomic(xc, Mem.as<uint8_t>(), EA,
                vl * this->sew, this->memAccessFlags, nullptr, byte_enable);
        }

        if (fault == NoFault) {
            %(postacc_code)s;
            %(op_wb)s;
        }

        return fault;
    }
}};

def template VMemStoreInitiateAcc {{
    Fault %(class_name)s::initiateAcc(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        auto tc = xc->tcBase();
        size_t vl = RiscvStaticInst::getCurVL(tc);
        STATUS status = xc->readMiscReg(MISCREG_STATUS);

        %(op_src_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        static const std::vector<bool> byte_enable(vl * this->sew, true);

        if (status.vs == static_cast<int>(VPUStatus::OFF))
            fault = std::make_shared<IllegalInstFault>("VPU is off", machInst);
        // read old data
        if (fault == NoFault) {
            fault = readMemAtomic(xc, EA, Mem.as<uint8_t>(), 
                vl * this->sew, this->memAccessFlags, byte_enable);
        }
        if (fault == NoFault) {
            const RiscvISA::vreg_t& tmp_v0 = tc->readVecReg(RegId(VecRegClass, 0));
            auto v0 = tmp_v0.as<uint8_t>();
            // update new data
            for (int i=0; i<vl; i++) {
                if (vm || v0[i]) {
                    %(memacc_code)s;
                }
            }
            Fault fault = writeMemAtomic(xc, Mem.as<uint8_t>(), EA,
                vl * this->sew, this->memAccessFlags, nullptr, byte_enable);
        }

        %(op_wb)s;

        return fault;
    }
}};

def template VMemStoreCompleteAcc {{
    Fault %(class_name)s::completeAcc(PacketPtr pkt, ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

def format VMemLoadOp (
    memacc_code, ea_code = {{EA = Rs1;}},
    mem_flags=[], inst_flags=[]
) {{
    (header_output, decoder_output, decode_block, exec_output) = \
        VMemLoadStoreOpBase(name, Name, ea_code, memacc_code,
        mem_flags, inst_flags, 'VMemLoadOp', exec_template_base='VMemLoad')
}};

def format VMemStoreOp (
    memacc_code, ea_code = {{EA = Rs1;}},
    mem_flags=[], inst_flags=[]
) {{
    (header_output, decoder_output, decode_block, exec_output) = \
        VMemLoadStoreOpBase(name, Name, ea_code, memacc_code,
        mem_flags, inst_flags, 'VMemStoreOp',
        exec_template_base='VMemStore')
}};